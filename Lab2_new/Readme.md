# Паттерны (требуемые к использованию)
## **Factory method (фабричный метод)**
### Определение
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, экземпляры какого класса должны создаваться. Фабричный метод позволяет классу делегировать создание экземпляров подклассам.
### Применимость
* классу заранее неизвестно, объекты каких классов ему нужно создавать; 
* класс спроектирован так, чтобы объекты, которые он создает, определялись подклассами;
* класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и вам нужно локализовать информацию о том, какой класс принимает эти обязанности на себя
### Структура
![[Структура Factory method.png]]

### Участники
* Product (Document) — продукт:
	* определяет интерфейс объектов, создаваемых фабричным методом;
* ConcreteProduct (MyDocument) — конкретный продукт:
	* реализует интерфейс Product;
* Creator (Application) — создатель:
	* объявляет фабричный метод, возвращающий объект типа Product. Creator может также определять реализацию по умолчанию фабричного метода, который возвращает объект ConcreteProduct;
	* может вызывать фабричный метод для создания объекта Product.
* ConcreteCreator (MyApplication) — конкретный создатель:
	* замещает фабричный метод, возвращающий объект СoncreteProduct.

### Отношения
* Создатель полагается на свои подклассы в определении фабричного метода, который будет возвращать экземпляр подходящего конкретного продукта.
### Результаты
* Фабричные методы избавляют проектировщика от необходимости встраивать в код зависящие от приложения классы. Код имеет дело только с интерфейсом класса Product, поэтому он может работать с любыми определенными пользователями классами конкретных продуктов. Потенциальный недостаток фабричного метода состоит в том, что клиентам, возможно, придется создавать подкласс класса Creator для создания лишь одного объекта ConcreteProduct. Порождение подклассов оправданно, если клиенту так или иначе приходится создавать подклассы Creator, в противном случае клиенту придется иметь дело с дополнительным уровнем подклассов.
## **Singleton (ОДИНОЧКА)**
### Определение
Гарантирует, что у класса существует только один экземпляр, и предоставляет к нему глобальную точку доступа.
### Применимость
* Должен существовать ровно один экземпляр некоторого класса, к которому может обратиться любой клиент через известную точку доступа;
* Единственный экземпляр должен расширяться путем порождения подклассов, а клиенты должны иметь возможность работать с расширенным экземпляром без модификации своего кода.
### Структура
![[Структура Singletion.png]]
### Участники
* Singleton — одиночка:
	* определяет операцию Instance, которая позволяет клиентам получить доступ к единственному экземпляру;
	* может нести ответственность за создание собственного уникального экземпляра
### Отношения
* Клиенты получают доступ к экземпляру класса Singleton только через его операцию Instance.
### Результаты
* Контролируемый доступ к единственному экземпляру;
* Сокращение пространства имен;
* Возможность уточнения операций и представления;
* Возможность использования переменного числа экземпляров;
* Большая гибкость, чем у операций класса
## Observer (наблюдатель)
### Определение
Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом и автоматически обновляются.
### Применимость
* У абстракции есть два аспекта, один из которых зависит от другого. Инкапсуляции этих аспектов в разные объекты позволяют изменять и повторно использовать их независимо;
* При модификации одного объекта требуется изменить другие, и вы не знаете, сколько именно объектов нужно изменить;
* Один объект должен оповещать других, не делая предположений об уведомляемых объектах. Другими словами, объекты не должны быть тесно связаны между собой.
### Структура
![[Структура Observer.png]]
### Участники
* Subject — субъект:
	* располагает информацией о своих наблюдателях. За субъектом может «следить» любое число наблюдателей;
	* предоставляет интерфейс для присоединения и отделения наблюдателей;
* Observer — наблюдатель:
	* определяет интерфейс обновления для объектов, которые должны уведомляться об изменении субъекта;
* ConcreteSubject — конкретный субъект:
	* сохраняет состояние, представляющее интерес для конкретного наблюдателя ConcreteObserver;
	* посылает информацию своим наблюдателям, когда происходит изменение;
* ConcreteObserver — конкретный наблюдатель:
	* хранит ссылку на объект класса ConcreteSubject;
	* сохраняет данные, которые должны быть согласованы с данными субъекта;
	* реализует интерфейс обновления, определенный в классе Observer, чтобы поддерживать согласованность с субъектом.
### Отношения
* Объект ConcreteSubject уведомляет своих наблюдателей о любом изменении, которое могло бы привести к рассогласованности состояний наблюдателя и субъекта;
* После получения от конкретного субъекта уведомления об изменении объект ConcreteObserver может запросить у субъекта дополнительную информацию, которую использует для того, чтобы оказаться в состоянии, согласованном с состоянием субъекта.
### Результаты
* Абстрактная связанность субъекта и наблюдателя;
* Поддержка широковещательных коммуникаций;
* Неожиданные обновления. Поскольку наблюдатели не располагают информацией друг о друге, им неизвестно и о том, во что обходится изменение субъекта.